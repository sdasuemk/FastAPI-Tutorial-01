#https://refine.dev/blog/introduction-to-fast-api/#understanding-fastapi-by-building-a-rest-api-for-an-inventory-application
# CRUD operation with SQLite
# Trigger reload
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field
from typing import List, Optional
import databases
import sqlalchemy
from contextlib import asynccontextmanager

"""
Database Configuration
We use `databases` for async database support and `sqlalchemy` for defining the schema.
`DATABASE_URL` points to a local SQLite file `db.db`.
"""
DATABASE_URL = "sqlite:///./db.db"
database = databases.Database(DATABASE_URL)
metadata = sqlalchemy.MetaData()

# Define the Items table using SQLAlchemy Core
# This defines the structure of our database table 'items'.
items = sqlalchemy.Table(
    "items",
    metadata,
    sqlalchemy.Column("id", sqlalchemy.Integer, primary_key=True),
    sqlalchemy.Column("name", sqlalchemy.String),
    sqlalchemy.Column("quantity", sqlalchemy.Integer),
)

# Engine for creating tables (Synchronous)
# We use a synchronous engine only for the initial table creation on startup.
engine = sqlalchemy.create_engine(
    DATABASE_URL, connect_args={"check_same_thread": False}
)
metadata.create_all(engine)

"""
Pydantic Models
These models are used for data validation and documentation.
- ItemIn: Used for creating items (no ID required).
- ItemPatch: Used for partial updates (all fields optional).
- Item: Used for responses (includes ID).
"""
class ItemIn(BaseModel):
    name: str = Field(..., title="Item Name", description="The name of the item", min_length=1)
    quantity: int = Field(..., title="Quantity", description="Quantity of the item", ge=0)

class ItemPatch(BaseModel):
    name: Optional[str] = Field(None, title="Item Name", description="The name of the item", min_length=1)
    quantity: Optional[int] = Field(None, title="Quantity", description="Quantity of the item", ge=0)

class Item(ItemIn):
    id: int = Field(..., title="Item ID", description="Unique identifier for the item")

"""
Lifespan Context Manager
This replaces the deprecated @app.on_event("startup") and "shutdown".
It handles connecting to the database when the app starts and disconnecting when it stops.
"""
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Connect to the database on startup
    await database.connect()
    yield
    # Disconnect from the database on shutdown
    await database.disconnect()

# FastAPI App Initialization with Metadata
app = FastAPI(
    title="FastAPI Inventory Manager",
    description="""
    A comprehensive tutorial application demonstrating **CRUD** operations with **SQLite**.
    
    ## Features
    * **Create** items using POST.
    * **Read** items using GET.
    * **Update** items using PUT (full) and PATCH (partial).
    * **Delete** items using DELETE.
    """,
    version="1.0.0",
    terms_of_service="http://example.com/terms/",
    contact={
        "name": "Tutorial Support",
        "url": "http://example.com/contact/",
        "email": "support@example.com",
    },
    license_info={
        "name": "Apache 2.0",
        "url": "https://www.apache.org/licenses/LICENSE-2.0.html",
    },
    lifespan=lifespan,
    openapi_tags=[
        {"name": "Items", "description": "Operations with inventory items."}
    ]
)

@app.post("/items", response_model=Item, tags=["Items"], summary="Create a new item", response_description="The created item with its ID.")
async def create_item(item: ItemIn):
    """
    Create an item by providing a name and quantity.
    The ID will be auto-generated by the database.
    """
    query = items.insert().values(name=item.name, quantity=item.quantity)
    last_record_id = await database.execute(query)
    return {**item.model_dump(), "id": last_record_id}

@app.get("/items", response_model=List[Item], tags=["Items"], summary="List all items", response_description="A list of all inventory items.")
async def read_items():
    """
    Retrieve all items currently stored in the database.
    """
    query = items.select()
    return await database.fetch_all(query)

@app.get("/items/{item_id}", response_model=Item, tags=["Items"], summary="Get item by ID", response_description="The requested item details.")
async def read_item(item_id: int):
    """
    Retrieve a specific item by its unique ID.
    If the item does not exist, a 404 error is returned.
    """
    query = items.select().where(items.c.id == item_id)
    item = await database.fetch_one(query)
    if item is None:
        raise HTTPException(status_code=404, detail="Item not found")
    return item

@app.put("/items/{item_id}", response_model=Item, tags=["Items"], summary="Update item (Full)", response_description="The fully updated item.")
async def update_item(item_id: int, item: ItemIn):
    """
    **Full Update**: Replaces the entire item with the new data.
    All fields (name, quantity) must be provided.
    """
    query = items.update().where(items.c.id == item_id).values(name=item.name, quantity=item.quantity)
    # Check if item exists before updating
    check_query = items.select().where(items.c.id == item_id)
    existing_item = await database.fetch_one(check_query)
    if existing_item is None:
         raise HTTPException(status_code=404, detail="Item not found")

    await database.execute(query)
    return {**item.model_dump(), "id": item_id}

@app.patch("/items/{item_id}", response_model=Item, tags=["Items"], summary="Update item (Partial)", response_description="The updated item.")
async def patch_item(item_id: int, item: ItemPatch):
    """
    **Partial Update**: Updates only the fields provided in the request body.
    Fields not provided (null) will remain unchanged.
    """
    check_query = items.select().where(items.c.id == item_id)
    existing_item = await database.fetch_one(check_query)
    if existing_item is None:
         raise HTTPException(status_code=404, detail="Item not found")

    # Filter out None values to update only provided fields
    update_data = {k: v for k, v in item.model_dump().items() if v is not None}

    if not update_data:
        return existing_item

    query = items.update().where(items.c.id == item_id).values(**update_data)
    await database.execute(query)
    
    # Return updated item
    return await database.fetch_one(check_query)

@app.delete("/items/{item_id}", tags=["Items"], summary="Delete item", response_description="Confirmation message.")
async def delete_item(item_id: int):
    """
    Deletes an item from the inventory by its ID.
    This action is irreversible.
    """
    query = items.delete().where(items.c.id == item_id)
    # Check if item exists before deleting
    check_query = items.select().where(items.c.id == item_id)
    existing_item = await database.fetch_one(check_query)
    if existing_item is None:
         raise HTTPException(status_code=404, detail="Item not found")

    await database.execute(query)
    return {"message": "Item deleted"}